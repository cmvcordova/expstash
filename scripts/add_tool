#!/usr/bin/env python3
"""
Add a Hydra-based tool to experimentStash.

Only copies config.yaml (base defaults list). Tool configs (algorithms/, data/,
metrics/) resolve at runtime via pkg:// SearchPathPlugins — copying them creates
stale shadows that silently override upstream defaults.

Usage:
  python3 scripts/add_tool geomancy https://github.com/lrw/geomancy
  python3 scripts/add_tool manylatents https://github.com/lrw/manylatents --entrypoint "-m manylatents.main"
"""

import argparse
import shutil
import subprocess
import sys
from pathlib import Path
from typing import List, Optional

import yaml


def run(cmd: List[str], cwd: Optional[Path] = None) -> bool:
    """Run command, return success."""
    result = subprocess.run(cmd, cwd=cwd, capture_output=True, text=True)
    if result.returncode != 0:
        print(f"[ERROR] {' '.join(cmd)}: {result.stderr}")
        return False
    return True


def add_submodule(name: str, repo_url: str) -> bool:
    """Add git submodule if not exists."""
    tool_path = Path(f"tools/{name}")
    if tool_path.exists():
        print(f"[INFO] Tool already exists: {tool_path}")
        return True

    print(f"[INFO] Adding submodule: {repo_url} -> {tool_path}")
    return run(["git", "submodule", "add", repo_url, f"tools/{name}"])


def install_deps(name: str) -> bool:
    """Install tool dependencies with uv."""
    tool_path = Path(f"tools/{name}")
    print(f"[INFO] Installing dependencies in {tool_path}")
    return run(["uv", "sync"], cwd=tool_path)


def setup_configs(name: str) -> bool:
    """Set up config stash — only copy config.yaml, create experiment/ dir.

    Tool configs (algorithms/, data/, metrics/, etc.) resolve at runtime via
    Hydra's pkg:// SearchPathPlugin. Copying them into the stash creates stale
    shadows that silently override upstream defaults.
    """
    tool_config = Path(f"tools/{name}/{name}/configs")
    if not tool_config.exists():
        tool_config = Path(f"tools/{name}/configs")

    dst = Path(f"configs/{name}")
    dst.mkdir(parents=True, exist_ok=True)

    # Create experiment directory for project-specific overrides
    (dst / "experiment").mkdir(exist_ok=True)

    # Copy only config.yaml (the base defaults list)
    base_config = tool_config / "config.yaml"
    if base_config.exists():
        shutil.copy2(base_config, dst / "config.yaml")
        print(f"  Copied: config.yaml (base defaults)")
    elif tool_config.exists():
        print(f"[WARNING] No config.yaml found at {tool_config}")
    else:
        print(f"[WARNING] No configs found at {tool_config}")

    print(f"[INFO] Config stash created at {dst}")
    print(f"  Project-specific experiment configs go in {dst / 'experiment'}/")
    print(f"  Tool configs (algorithms/, data/, etc.) resolve from pkg:// at runtime")
    return True


def check_extensions(name: str) -> bool:
    """Check for entry-point extensions registered by the tool."""
    tool_path = Path(f"tools/{name}")
    venv_python = tool_path / ".venv" / "bin" / "python3"
    if not venv_python.exists():
        venv_python = tool_path / ".venv" / "bin" / "python"

    if not venv_python.exists():
        print("[INFO] No venv found — skipping extension check")
        return True

    code = (
        "from importlib.metadata import entry_points; "
        "eps = entry_points(); "
        "groups = [g for g in (eps if isinstance(eps, dict) else {}) "
        "if 'searchpath' in g or 'hydra' in g]; "
        "[print(f'  {g}: {e.name} -> {e.value}') "
        "for g in sorted(set(groups)) for e in "
        "(eps[g] if isinstance(eps, dict) else eps(group=g))]"
    )
    result = subprocess.run(
        [str(venv_python), "-c", code],
        cwd=tool_path,
        capture_output=True,
        text=True,
    )
    if result.stdout.strip():
        print("[INFO] Discovered extension entry points:")
        print(result.stdout.rstrip())
    else:
        print("[INFO] No extension entry points found (extensions register via pkg:// SearchPathPlugins)")
    return True


def update_meta(name: str, entrypoint: str, description: str) -> bool:
    """Add tool to meta.yaml."""
    meta_path = Path("configs/meta.yaml")
    meta = yaml.safe_load(meta_path.read_text())

    if name in meta.get("tools", {}):
        print(f"[INFO] Tool '{name}' already in meta.yaml")
        return True

    meta.setdefault("tools", {})[name] = {
        "path": f"tools/{name}",
        "entrypoint": entrypoint,
        "description": description,
    }

    meta_path.write_text(yaml.dump(meta, default_flow_style=False, sort_keys=False))
    print(f"[INFO] Added '{name}' to meta.yaml")
    return True


def verify_decorator(name: str) -> bool:
    """Check if decorator allows CLI config overrides."""
    main_py = Path(f"tools/{name}/{name}/main.py")
    if not main_py.exists():
        main_py = Path(f"tools/{name}/src/main.py")

    if not main_py.exists():
        print(f"[WARNING] Could not find main.py to verify decorator")
        return True

    content = main_py.read_text()
    if "config_path=None" in content:
        print("[OK] Decorator uses config_path=None (CLI-compatible)")
        return True

    print("[WARNING] Decorator has hardcoded config_path.")
    print("         Change to: @hydra.main(config_path=None, config_name=None, version_base=None)")
    return True  # Warning only, not failure


def main():
    parser = argparse.ArgumentParser(description="Add a Hydra tool to experimentStash")
    parser.add_argument("name", help="Tool name (e.g., geomancy)")
    parser.add_argument("repo_url", help="Git repository URL")
    parser.add_argument("--entrypoint", default=None, help="Entrypoint (default: -m <name>.main)")
    parser.add_argument("--description", default="", help="Tool description")
    parser.add_argument("--skip-deps", action="store_true", help="Skip dependency installation")
    args = parser.parse_args()

    entrypoint = args.entrypoint or f"-m {args.name}.main"
    description = args.description or f"{args.name} - Hydra-based tool"

    steps = [
        ("Add submodule", lambda: add_submodule(args.name, args.repo_url)),
        ("Install deps", lambda: install_deps(args.name) if not args.skip_deps else True),
        ("Check extensions", lambda: check_extensions(args.name)),
        ("Setup configs", lambda: setup_configs(args.name)),
        ("Update meta.yaml", lambda: update_meta(args.name, entrypoint, description)),
        ("Verify decorator", lambda: verify_decorator(args.name)),
    ]

    for step_name, step_fn in steps:
        print(f"\n=== {step_name} ===")
        if not step_fn():
            print(f"[ERROR] Failed at: {step_name}")
            return 1

    print("\n" + "=" * 60)
    print(f"[OK] Tool '{args.name}' added successfully!")
    print("=" * 60)
    print(f"\nDirect invocation:")
    print(f"  cd tools/{args.name}")
    print(f"  python3 {entrypoint} --config-path=../../configs/{args.name} experiment=<name>")
    return 0


if __name__ == "__main__":
    sys.exit(main())
